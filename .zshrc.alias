# Common aliases
alias a="alias"
alias dateh="date +%d-%m-%y"
alias rm='rm -f'
alias wget='wget -c'
alias p='pnpm'
alias b='brew'
alias n='npm'
alias ka='killall'
alias k9='f() { killall -9 ${1}};f'
alias large-files="du -ah . | sort -nr | head"
alias tf='tail -f '
alias ag='ag -a'
alias rg='rg --smart-case --follow --hidden'

# Clean search using ripgrep with proper exclusions
clean-search() {
    local pattern="$1"
    local path="${2:-.}"

    echo "🔍 Clean search for: '$pattern' in: $path"
    echo "📏 Excluding node_modules, extensions, minified files, etc."
    echo ""

    # Use ripgrep with comprehensive exclusions
    /opt/homebrew/bin/rg -n "$pattern" "$path" \
        --glob '!**/node_modules/**' \
        --glob '!**/.vscode/extensions/**' \
        --glob '!**/*.min.js' \
        --glob '!**/*.bundle.js' \
        --glob '!**/dist/**' \
        --glob '!**/build/**' \
        --glob '!**/.cache/**' \
        --glob '!**/.npm/**' \
        --glob '!**/.bun/**' \
        --glob '!**/.next/**' \
        --glob '!**/.nuxt/**' \
        --glob '!**/target/**' \
        --glob '!**/__pycache__/**' \
        2>/dev/null
}

# Simple home search function
search-home() {
    local pattern="$1"
    echo "🏠 Searching home directory for: '$pattern'"
    clean-search "$pattern" "$HOME"
}

# Alternative: Use ripgrep with type filtering for cleaner results
search-code() {
    local pattern="$1"
    local type="${2:-js}"

    echo "🔍 Searching for '$pattern' in $type files:"
    rg --type="$type" -n "$pattern" 2>/dev/null | head -15
}

# Quick aliases for common searches
alias rjs='rg --type=js'
alias rts='rg --type=ts'
alias rpy='rg --type=py'
alias rmd='rg --type=md'

# Smart search with minified file filtering
smart-grep() {
    local pattern="$1"
    local path="${2:-.}"
    echo "🔍 Smart grep for: '$pattern' in: $path"
    echo "📏 Filtering out minified/single-line files"
    echo ""

    ag "$pattern" "$path" 2>/dev/null | /usr/bin/awk -F: '
    {
        file = $1
        line = $2
        content = $3
        for(i=4; i<=NF; i++) content = content ":" $i

        # Skip excluded directories
        if(file ~ /\.vscode\/extensions\//) next
        if(file ~ /node_modules\//) next
        if(file ~ /\.npm\//) next
        if(file ~ /\.bun\//) next
        if(file ~ /\.cache\//) next
        if(file ~ /\.Trash\//) next

        # Check file properties
        cmd = "/usr/bin/wc -l < \"" file "\" 2>/dev/null"
        cmd | getline line_count
        close(cmd)

        cmd = "/usr/bin/awk '\''length > 2000 {count++} END {print count+0}'\'' \"" file "\" 2>/dev/null"
        cmd | getline long_lines
        close(cmd)

        # Skip problematic files
        if(line_count <= 1 || long_lines > 0) next

        print file ":" line ":" content
    }'
}
alias jtags="ctags -R src && sed -i '' -E '/^(if|switch|function|module\.exports|it|describe).+language:js$/d' tags"
alias f='fuck'
alias sl='screen -list'
alias sr='screen -r'
alias sd='screen -d'
alias claude="/Users/yann/.claude/local/claude"

# Development aliases
# alias gpt='python /path/to/your/gpt/script.py'  # Update path as needed
alias gypton=gpt

alias myip="curl http://ipecho.net/plain; echo"
alias whatsmyip=myip
alias fix-gitignore='git rm -r --cached . && git add . && git commit -m "fixed untracked files"'
alias h="htop"

# Editor aliases
HAS_NVIM=$(which nvim 2>/dev/null)

if [ -n "$HAS_NVIM" ]; then
    alias v="nvim"
    alias nv="nvim"                    # Persisted plugin auto-loads sessions
    alias vv="nvim"                    # Persisted plugin auto-loads sessions
    alias nvp="nvim --noplugin"
    alias vp="nvim --noplugin"
    alias nvo="nvim -c SessionLoad"    # Explicitly load session picker
    alias nvs="nvim -c SessionSave"    # Quick session save
    alias nvt="nvim -p"                # Open files in tabs
    alias vt="nvim -p"                 # Open files in tabs
else
    alias v="vim"
    alias nv="vim -c OpenSession"
    alias vv="vim -c OpenSession"
    alias nvp="vim --noplugin"
    alias vp="vim --noplugin"
    alias nvo="vim -c OpenSession"
    alias vt="vim -p"                  # Open files in tabs
fi

# Yarn/Node
alias ytu='yarn test -u'

# Git aliases
alias quote="curl -s https://api.quotable.io/quotes/random | jq '.[].content,.[].author'"
alias hh='yarn hardhat'
alias gp='git push'
alias gs='git stash save'
alias gpr='git pull -r'
alias gpot='git push origin && git push origin --tags'
alias gca='git commit --amend --no-edit'
alias gcommit='f() { git add -v ${1} && git commit --message="${2}"  };f'
alias grf='f() { git reset ${1} };f'
alias gcommit-and-push='f() {git add -v ${1} && git commit --message="${2}" && git push};f'
alias gmod='git fetch && git merge origin/develop'

# Additional git aliases
alias ga='git add'
alias gc='git commit'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'

# Common navigation
# Use eza if available, otherwise fall back to ls
if command -v eza &> /dev/null; then
    alias ls='eza --color=always --group-directories-first'
    alias ll='eza -alF --color=always --group-directories-first --icons'
    alias la='eza -a --color=always --group-directories-first --icons'
    alias l='eza -CF --color=always --group-directories-first --icons'
    alias lt='eza --tree --color=always --group-directories-first --icons'
else
    alias ll='ls -alF'
    alias la='ls -A'
    alias l='ls -CF'
    alias lt='tree'  # fallback to tree command if available
fi

# Use bat if available, otherwise fall back to cat
if command -v bat &> /dev/null; then
    alias cat='bat --paging=never'
    alias bcat='bat'  # bat with paging
    alias batl='bat --paging=always'  # bat with paging (explicit)
else
    alias bcat='cat'  # fallback
    alias batl='less'  # fallback with paging
fi

alias ..='cd ..'
alias ...='cd ../..'

# Editor
alias c="cursor"

# Functions
function fix-gitignore() {
    git rm -r --cached .
    git add .
    git commit -m "fixed untracked files"
}

# Github helper functions
function clone-rep() {
    cd ~/dev/cloned
    git clone ${1}
    repo=`echo ${1} | cut -d / -f 5`
    cd ${repo}
}

function clone-rep-and-install() {
    cd ~/dev/cloned && git clone ${1}
    repo=`echo ${1} | cut -d / -f 5`
    cd ${repo}
    npm install
}

function update-children-repos() {
    for dir in `ls`
    do
        cd $dir
        rebase=`git pull -r`
        if [ $? -ne 0 ]; then
            echo "error pulling $dir"
        else
            echo "$dir: $rebase"
        fi
        cd ..
    done
}

# fd + ripgrep integration functions
if command -v fd &> /dev/null && command -v rg &> /dev/null; then
    # Find files by name, then search content
    function fif() {
        rg --files-with-matches --no-messages "$1" | fzf --preview "rg --ignore-case --pretty --context 10 '$1' {}"
    }

    # Interactive ripgrep - search content then edit
    function rgf() {
        local file
        file=$(rg --files-with-matches --no-messages "$1" | fzf --preview "rg --ignore-case --pretty --context 10 '$1' {}") && [ -n "$file" ] && ${EDITOR:-vim} "$file"
    }

    # Find directory and cd into it
    function fcd() {
        local dir
        dir=$(fd --type d | fzf) && cd "$dir"
    }
fi

# Conditional fd aliases (like we did for eza and bat)
if command -v fd &> /dev/null; then
    alias find='fd'
    alias findf='fd --type f'  # find files only
    alias findd='fd --type d'  # find directories only
else
    alias findf='find . -type f -name'
    alias findd='find . -type d -name'
fi

# Add your custom aliases here
# Smart ag function with automatic minified file filtering
smart-ag() {
    local pattern="$1"
    shift

    # Handle the case where ~/.* expands to many files
    if [[ $# -gt 1 && "$*" == *"/Users/"*"/."* ]]; then
        # If we have many dotfiles, search the home directory instead
        local search_path="$HOME"
        echo "🔍 Smart ag search for: '$pattern' in: $HOME (optimized from glob expansion)"
    else
        # Normal case: join arguments back or use current directory
        local search_path="${*:-.}"
        echo "🔍 Smart ag search for: '$pattern' in: $search_path"
    fi

    echo "📏 Automatically filtering out build/cache directories"
    echo ""

    # Use the original ag binary directly to avoid recursion
    # First do the basic filtering with ag's built-in ignore options
    /opt/homebrew/bin/ag --ignore-dir=.vscode/extensions --ignore-dir=.npm --ignore-dir=.bun --ignore-dir=.cache --ignore-dir=.Trash --ignore-dir=node_modules --ignore-dir=dist --ignore-dir=build --ignore-dir=.local --ignore-dir=.next --ignore-dir=.nuxt "$pattern" "$search_path" 2>/dev/null
}

# Keep original ag available as 'ag-raw'
alias ag-raw='/opt/homebrew/bin/ag --ignore-dir=dist --ignore-dir=build --ignore-dir=node_modules --ignore="*.min.js" --ignore="*.bundle.js" --ignore="*.chunk.js"'
# Override default ag with smart filtering
alias ag='smart-ag'
